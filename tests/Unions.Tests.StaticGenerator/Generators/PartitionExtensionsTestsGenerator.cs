using Toarnbeike.Unions.Utitilies;

namespace Toarnbeike.Unions.Generators;

/// <summary>
/// Generates tests for the Partition collection extension methods.
/// This code is build-time tooling; readability and determinism are preferred over abstraction.
/// </summary>
internal static class PartitionExtensionsTestsGenerator
{

    private static int[] _arities = null!;
    private static string _union = null!;

    public static string Generate(int arity)
    {
        _arities = [.. Enumerable.Range(1, arity)];
        _union = $"Union<{string.Join(',', _arities.Select(i => "U" + i))}>";

        return $$"""
            {{AutoGeneratedMessageGenerator.GetAutoGeneratedMessage(nameof(PartitionExtensionsTestsGenerator))}}

            using Toarnbeike.Unions.Collections;
            using Toarnbeike.Unions.Tests.Unions.TestTypes;

            namespace Toarnbeike.Unions.Tests.Collections.Partitions.Generated;

            public class Partition{{arity:D2}}Tests
            {
            {{string.Join("\n", _arities.Select(SelectT))}}
            {{Partition()}}

                private IEnumerable<{{_union}}> CreateMixedCollection()
                {
            {{string.Join("\n", _arities.Select(CreateMixedCollection))}}
                }
                {{string.Join("\n", _arities.Select(CreateUCollection))}}
            }
            """;
    }

    private static string SelectT(int arity)
    {
        var alternativeArity = arity == 1 ? 2 : 1;
        return $$"""
                
                [Test]
                public void SelectT{{arity}}_Should_Return_OnlyT{{arity}}Values()
                {
                    var source = CreateMixedCollection();

                    var t{{arity}}Values = source.SelectT{{arity}}().ToList();

                    t{{arity}}Values.Count.ShouldBe(2);
                    t{{arity}}Values[0].Value.ShouldBe({{arity}});
                    t{{arity}}Values[1].Value.ShouldBe({{arity + 1}});
                }

                [Test]
                public void SelectT{{arity}}_Should_ReturnEmptyCollection_WhenNoT{{arity}}Values()
                {
                    var source = CreateU{{alternativeArity}}Collection();
                    var t{{arity}}Values = source.SelectT{{arity}}().ToList();
                    
                    t{{arity}}Values.ShouldBeEmpty();
                }
            """;
    }

    private static string Partition()
    {
        return $$"""
                
                [Test]
                public void Partition_Should_SplitMixedCollection()
                {
                    var source = CreateMixedCollection();

                    var ({{string.Join(", ", _arities.Select(i => $"t{i}Values"))}}) = source.Partition();

                    {{string.Join("\n        ", _arities.Select(i => $@"t{i}Values.Count.ShouldBe(2);"))}}
                }

                [Test]
                public void Partition_Should_ReturnEmptyCollections_WhenNoValues()
                {
                    var source = Enumerable.Empty<{{_union}}>();

                    var ({{string.Join(", ", _arities.Select(i => $"t{i}Values"))}}) = source.Partition();

                    {{string.Join("\n        ", _arities.Select(i => $"t{i}Values.ShouldBeEmpty();"))}}
                }
            """;
    }

    private static string CreateMixedCollection(int arity)
    {
        return $$"""
                    yield return {{_union}}.FromT{{arity}}(new U{{arity}}({{arity}}));
                    yield return {{_union}}.FromT{{arity}}(new U{{arity}}({{arity + 1}}));
            """;
    }

    private static string CreateUCollection(int arity)
    {
        return $$"""
                
                private IEnumerable<{{_union}}> CreateU{{arity}}Collection()
                {
                    yield return {{_union}}.FromT{{arity}}(new U{{arity}}(1));
                    yield return {{_union}}.FromT{{arity}}(new U{{arity}}(2));
                    yield return {{_union}}.FromT{{arity}}(new U{{arity}}(3));
                }
            """;
    }
}