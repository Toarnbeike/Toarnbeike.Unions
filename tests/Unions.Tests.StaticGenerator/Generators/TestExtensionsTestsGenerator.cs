using Toarnbeike.Unions.Tests.Utitilies;

namespace Toarnbeike.Unions.Tests.Generators;

/// <summary>
/// Generates tests for the Test extension methods.
/// This code is build-time tooling; readability and determinism are preferred over abstraction.
/// </summary>
internal class TestExtensionsTestsGenerator
{
    private static int[] _arities = null!;
    private static string _union = null!;

    public static string Generate(int arity)
    {
        _arities = [.. Enumerable.Range(1, arity)];
        _union = $"Union<{string.Join(',', _arities.Select(i => "U" + i))}>";

        return $$"""
            {{AutoGeneratedMessageGenerator.GetAutoGeneratedMessage(nameof(TestExtensionsTestsGenerator))}}

            using Toarnbeike.Unions.Generic;
            using Toarnbeike.Unions.Generic.TestExtensions;
            using Toarnbeike.Unions.Tests.TestTypes;

            namespace Toarnbeike.Unions.Tests.TestExtensions.Generated;

            public class TestExtensions{{arity:D2}}Tests
            {
            {{string.Join("\n", _arities.Select(FactoryMethod))}}
            {{string.Join("\n", _arities.Select(ShouldBeTests))}}
            }
            """;
    }

    private static string FactoryMethod(int arity)
    {
        return $"    private static {_union} MakeT{arity}(int v) => {_union}.FromT{arity}(new U{arity}(v));";
    }

    private static string ShouldBeTests(int arity)
    {
        var otherArity = arity == 1 ? 2 : 1;
        return $$"""

            [Test]
            public void ShouldBeT{{arity}}_Should_ReturnT{{arity}}Value_WhenUnionIsT{{arity}}()
            {
                var union = MakeT{{arity}}({{arity}});

                var result = union.ShouldBeT{{arity}}();

                result.Value.ShouldBe({{arity}});
            }

            [Test]
            public void ShouldBeT{{arity}}_Should_Throw_WhenUnionIsUninitialized()
            {
                {{_union}} union = default;

                Should.Throw<AssertionFailedException>(() => union.ShouldBeT{{arity}}()).Message.ShouldBe("Union is in the uninitialized (default) state.");
            }

            [Test]
            public void ShouldBeT{{arity}}_Should_Throw_WhenUnionIsOtherArity()
            {
                var union = MakeT{{otherArity}}({{otherArity}});

                Should.Throw<AssertionFailedException>(() => union.ShouldBeT{{arity}}()).Message.ShouldBe("Expected union to be T{{arity}}, but it was T{{otherArity}} (T{{otherArity}} (U{{otherArity}}) = U{{otherArity}} { Value = {{otherArity}} }).");
            }

            [Test]
            public void ShouldBeT{{arity}}_Should_Pass_WhenEqualToExpectedValue()
            {
                var union = MakeT{{arity}}({{arity}});
                var expected = new U{{arity}}({{arity}});

                var result = union.ShouldBeT{{arity}}(expected);
                result.ShouldBe(expected);
            }

            [Test]
            public void ShouldBeT{{arity}}_Should_Throw_WhenNotEqualToExpectedValue()
            {
                var union = MakeT{{arity}}({{arity}});
                var expected = new U{{arity}}(100);
                Should.Throw<AssertionFailedException>(() => union.ShouldBeT{{arity}}(expected)).Message.ShouldBe("Expected T{{arity}} value to be U{{arity}} { Value = 100 }, but it was U{{arity}} { Value = {{arity}} }.");
            }
            """;
    }
}

