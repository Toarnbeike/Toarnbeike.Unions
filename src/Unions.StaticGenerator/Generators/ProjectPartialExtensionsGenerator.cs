using Toarnbeike.Unions.Utilities;

namespace Toarnbeike.Unions.Generators;

/// <summary>
/// Generates the union.ProjectT extension methods for the requested arities.
/// This code is build-time tooling; readability and determinism are preferred over abstraction.
/// </summary>
/// <remarks> The ProjectExtenions are generated in <see cref="ProjectFullExtensionsGenerator"/></remarks>
internal static class ProjectPartialExtensionsGenerator
{
    public static string Generate(IEnumerable<int> arities)
    {
        return $$"""
            {{AutoGeneratedMessageGenerator.GetAutoGeneratedMessage(nameof(ProjectPartialExtensionsGenerator))}}
            
            namespace Toarnbeike.Unions.Extensions;

            /// <summary>
            /// Project: extension methods to project (transform) union values.
            /// This is a union modifying operation, the resulting union has a different type compared to the original.
            /// For type perserving operation, prefer <see cref="MapExtensions"/>
            /// </summary>
            /// <remarks> 
            /// This file deals with partial projections, transforming one specific case of the union.
            /// For full projections, see the other part of this partial class.
            /// </remarks>
            public static partial class ProjectExtensions
            {{{string.Join("\n", arities.Select(GenerateProjections))}}
            }
            """;
    }

    private static string GenerateProjections(int arity)
    {
        var arities = Enumerable.Range(1, arity).ToArray();
        var genericArgs = $"<{string.Join(", ", arities.Select(i => $"T{i}"))}>";
        return $$"""

                     #region Projection Extensions for Union{{genericArgs}}

                     extension{{genericArgs}}(Union{{genericArgs}} union)
                     {
                 {{string.Join("\n", arities.Select(i => ProjectT(i, arities)))}}
                 {{string.Join("\n", arities.Select(i => ProjectAsyncT(i, arities)))}}
                     }
                     
                     extension{{genericArgs}}(Task<Union{{genericArgs}}> unionTask)
                     {
                 {{string.Join("\n", arities.Select(i => TaskProjectT(i, arities)))}}
                 {{string.Join("\n", arities.Select(i => TaskProjectAsyncT(i, arities)))}}
                     }

                     #endregion
                 """;
    }

    private static string ProjectT(int arity, int[] arities)
    {
        var newArgs = $"<{string.Join(", ", arities.Select(i => i == arity ? "TNew" : $"T{i}"))}>";
        return $$"""

                        /// <summary>
                        /// Apply a projection function to the value stored in the union if it is in the T{{arity}} state.
                        /// </summary>
                        /// <param name="projection">The projecting function to apply.</param>
                        public Union{{newArgs}} ProjectT{{arity}}<TNew>(Func<T{{arity}}, TNew> projection)
                        {
                            ArgumentNullException.ThrowIfNull(projection);

                            return union.Match(
                               {{string.Join(",\n              ", arities.Select(i => MatchLine(i, newArgs, i == arity)))}}
                            );
                        }
                 """;
    }

    private static string ProjectAsyncT(int arity, int[] arities)
    {
        var newArgs = $"<{string.Join(", ", arities.Select(i => i == arity ? "TNew" : $"T{i}"))}>";
        return $$"""

                        /// <summary>
                        /// Apply an async projecting function to the value stored in the union if it is in the T{{arity}} state.
                        /// </summary>
                        /// <param name="projectionAsync">The projecting function to apply.</param>
                        public Task<Union{{newArgs}}> ProjectT{{arity}}Async<TNew>(Func<T{{arity}}, Task<TNew>> projectionAsync)
                        {
                            ArgumentNullException.ThrowIfNull(projectionAsync);

                            return union.MatchAsync(
                               {{string.Join(",\n              ", arities.Select(i => MatchLineAsync(i, newArgs, i == arity)))}}
                            );
                        }                           
                 """;
    }

    private static string TaskProjectT(int arity, int[] arities)
    {
        var newArgs = $"<{string.Join(", ", arities.Select(i => i == arity ? "TNew" : $"T{i}"))}>";
        return $$"""

                        /// <summary>
                        /// Apply a projecting function to the value stored in the task union if it is in the T{arity} state.
                        /// </summary>
                        /// <param name="projection">The projecting function to apply.</param>
                        public async Task<Union{{newArgs}}> ProjectT{{arity}}<TNew>(Func<T{{arity}}, TNew> projection)
                        {
                            var union = await unionTask.ConfigureAwait(false);
                            return union.ProjectT{{arity}}(projection);
                        }
                 """;
    }

    private static string TaskProjectAsyncT(int arity, int[] arities)
    {
        var newArgs = $"<{string.Join(", ", arities.Select(i => i == arity ? "TNew" : $"T{i}"))}>";
        return $$"""

                        /// <summary>
                        /// Apply an async projecting function to the value stored in the task union if it is in the T{arity} state.
                        /// </summary>
                        /// <param name="projectionAsync">The projecting function to apply.</param>
                        public async Task<Union{{newArgs}}> ProjectT{{arity}}Async<TNew>(Func<T{{arity}}, Task<TNew>> projectionAsync)
                        {
                            var union = await unionTask.ConfigureAwait(false);
                            return await union.ProjectT{{arity}}Async(projectionAsync).ConfigureAwait(false);
                        }
                 """;
    }

    private static string MatchLine(int arity, string newArgs, bool isCurrent)
    {
        var argument = isCurrent ? $"projection(t{arity})" : $"t{arity}";
        return $"t{arity} => Union{newArgs}.FromT{arity}({argument})";
    }

    private static string MatchLineAsync(int arity, string newArgs, bool isCurrent)
    {
        return isCurrent
            ? $"    async t{arity} => Union{newArgs}.FromT{arity}(await projectionAsync(t{arity}).ConfigureAwait(false))"
            : $"    t{arity} => Task.FromResult(Union{newArgs}.FromT{arity}(t{arity}))";
    }
}