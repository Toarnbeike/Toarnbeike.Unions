using Toarnbeike.Unions.Utilities;

namespace Toarnbeike.Unions.Generators;

/// <summary>
/// This generates test extension methods for Union types to facilitate unit testing.
/// This code is build-time tooling; readability and determinism are preferred over abstraction.
/// </summary>
internal static class TestExtensionsGenerator
{
    public static string Generate(IEnumerable<int> arities)
    {
        return $$"""
            {{AutoGeneratedMessageGenerator.GetAutoGeneratedMessage(nameof(TestExtensionsGenerator))}}

            namespace Toarnbeike.Unions.TestExtensions;

            /// <summary>
            /// Provides extension methods for testing Union types in unit tests.
            /// </summary>
            public static class TestExtensions
            {{{string.Join("\n", arities.Select(GenerateTestExtension))}}
            }
            """;
    }

    private static string GenerateTestExtension(int arity)
    {
        var arityList = Enumerable.Range(1, arity).ToList();
        var genericArgs = $"<{string.Join(", ", arityList.Select(i => $"T{i}"))}>";
        return $$"""

                     #region Test Extensions for Union{{genericArgs}}

                     extension{{genericArgs}}(Union{{genericArgs}} union)
                     {
                 {{string.Join("\n", arityList.Select(ShouldBeT))}}
                     }

                     #endregion
                 """;
    }

    private static string ShouldBeT(int arity)
    {
        return $$"""

                         /// <summary>
                         /// Verifies that the union is in the T{{arity}} state.
                         /// </summary>
                         /// <returns>The value of the union, as T{{arity}}, if the union is in the T{{arity}} state.</returns>
                         /// <exception cref="AssertionFailedException">Thrown if the union is not in the T{{arity}} state.</exception>
                         public T{{arity}} ShouldBeT{{arity}}()
                         {
                             if (union.Index == 0)
                             {
                                 throw new AssertionFailedException("Union is in the uninitialized (default) state.");
                             }

                             return union.IsT{{arity}} 
                                 ? union.AsT{{arity}} 
                                 : throw new AssertionFailedException($"Expected union to be T{{arity}}, but it was T{union.Index} ({union.DebuggerToString()}).");
                         }

                         /// <summary>
                         /// Verifies that the union is in the T{{arity}} state and has the expected value.
                         /// </summary>
                         /// <param name="expected">The expected value of the union.</param>
                         /// <exception cref="AssertionFailedException">Thrown if the union is not in the T{{arity}} state, or if the value does not match the expected.</exception>
                         public T{{arity}} ShouldBeT{{arity}}(T{{arity}} expected)
                         {
                             var actual = union.ShouldBeT{{arity}}();
                             if (!EqualityComparer<T{{arity}}>.Default.Equals(actual, expected))
                             {
                                 throw new AssertionFailedException($"Expected T{{arity}} value to be {expected}, but it was {actual}.");
                             }
                             return actual;
                         }
                 """;
    }
}
