using Toarnbeike.Unions.Utilities;

namespace Toarnbeike.Unions.Generators;

/// <summary>
/// Generates the union.MapT extension methods for the requested arities.
/// This code is build-time tooling; readability and determinism are preferred over abstraction.
/// </summary>
/// <remarks> The MapExtenions are generated in <see cref="MapFullExtensionsGenerator"/></remarks>
internal static class MapPartialExtensionsGenerator
{
    public static string Generate(IEnumerable<int> arities)
    {
        return $$"""
            {{AutoGeneratedMessageGenerator.GetAutoGeneratedMessage(nameof(MapPartialExtensionsGenerator))}}
            
            namespace Toarnbeike.Unions.Extensions;

            /// <summary>
            /// Map: extension methods to map union values, modifying the inner value, but keeping the types equal (endomorphic).
            /// </summary>
            /// <remarks>
            /// This files deals with partial Map: transforms a single member of the union if the union is in that specific state.
            /// For modifying all values at once (full map), see the other part of this partial class.
            /// </summary>
            public static partial class MapExtensions
            {{{string.Join("\n", arities.Select(GenerateMap))}}
            }
            """;
    }

    private static string GenerateMap(int arity)
    {
        var arities = Enumerable.Range(1, arity).ToArray();
        var genericArgs = $"<{string.Join(", ", arities.Select(i => $"T{i}"))}>";
        return $$"""

                     #region Map Extensions for Union{{genericArgs}}

                     extension{{genericArgs}}(Union{{genericArgs}} union)
                     {
                 {{string.Join("\n", arities.Select(i => MapT(i, genericArgs)))}}
                 {{string.Join("\n", arities.Select(i => MapAsyncT(i, genericArgs)))}}
                     }
                     
                     extension{{genericArgs}}(Task<Union{{genericArgs}}> unionTask)
                     {
                 {{string.Join("\n", arities.Select(i => TaskMapT(i, genericArgs)))}}
                 {{string.Join("\n", arities.Select(i => TaskMapAsyncT(i, genericArgs)))}}
                     }

                     #endregion
                 """;
    }

    private static string MapT(int arity, string genericArgs)
    {
        return $$"""

                        /// <summary>
                        /// Apply a mapping function to the value stored in the union if it is in the T{{arity}} state.
                        /// </summary>
                        /// <param name="map">The mapping function to apply.</param>
                        public Union{{genericArgs}} MapT{{arity}}(Func<T{{arity}}, T{{arity}}> map)
                        {
                            ArgumentNullException.ThrowIfNull(map);

                             return union.TryGetT{{arity}}(out var value)
                                 ? Union{{genericArgs}}.FromT{{arity}}(map(value))
                                 : union;
                        }
                 """;
    }

    private static string MapAsyncT(int arity, string genericArgs)
    {
        return $$"""

                        /// <summary>
                        /// Apply an async mapping function to the value stored in the union if it is in the T{{arity}} state.
                        /// </summary>
                        /// <param name="mapAsync">The mapping function to apply.</param>
                        public async Task<Union{{genericArgs}}> MapT{{arity}}Async(Func<T{{arity}}, Task<T{{arity}}>> mapAsync)
                        {
                            ArgumentNullException.ThrowIfNull(mapAsync);

                             return union.TryGetT{{arity}}(out var value)
                                 ? Union{{genericArgs}}.FromT{{arity}}(await mapAsync(value).ConfigureAwait(false))
                                 : union;
                        }                           
                 """;
    }

    private static string TaskMapT(int arity, string genericArgs)
    {
        return $$"""

                        /// <summary>
                        /// Apply a mapping function to the value stored in the task union if it is in the T{arity} state.
                        /// </summary>
                        /// <param name="map">The mapping function to apply.</param>
                        public async Task<Union{{genericArgs}}> MapT{{arity}}(Func<T{{arity}}, T{{arity}}> map)
                        {
                            var union = await unionTask.ConfigureAwait(false);
                            return union.MapT{{arity}}(map);
                        }
                 """;
    }

    private static string TaskMapAsyncT(int arity, string genericArgs)
    {
        return $$"""

                        /// <summary>
                        /// Apply an async mapping function to the value stored in the task union if it is in the T{arity} state.
                        /// </summary>
                        /// <param name="mapAsync">The mapping function to apply.</param>
                        public async Task<Union{{genericArgs}}> MapT{{arity}}Async(Func<T{{arity}}, Task<T{{arity}}>> mapAsync)
                        {
                            var union = await unionTask.ConfigureAwait(false);
                            return await union.MapT{{arity}}Async(mapAsync).ConfigureAwait(false);
                        }
                 """;
    }
}