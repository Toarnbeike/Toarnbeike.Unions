using Toarnbeike.Unions.Utilities;

namespace Toarnbeike.Unions.Generators;

/// <summary>
/// Generates the union.Map extension methods for the requested arities.
/// This code is build-time tooling; readability and determinism are preferred over abstraction.
/// </summary>
/// <remarks> The MapTExtensions are generated in <see cref="MapPartialExtensionsGenerator"/></remarks>
internal static class MapFullExtensionsGenerator
{
    public static string Generate(IEnumerable<int> arities)
    {
        return $$"""
            {{AutoGeneratedMessageGenerator.GetAutoGeneratedMessage(nameof(MapFullExtensionsGenerator))}}
            
            namespace Toarnbeike.Unions.Generic.Extensions;

            /// <summary>
            /// Map: extension methods to map (transform) union values.
            /// </summary>
            /// <remarks> 
            /// This file deals with full mappings, transforming all possible types of the union at once.
            /// For partial transforming, see the other part of this partial class.
            /// </remarks>
            public static partial class MapExtensions
            {{{string.Join("\n", arities.Select(GenerateMaps))}}
            }
            """;
    }

    private static string GenerateMaps(int arity)
    {
        var arities = Enumerable.Range(1, arity).ToArray();
        var genericArgs = $"<{string.Join(", ", arities.Select(i => $"T{i}"))}>";
        var newArgs = $"<{string.Join(", ", arities.Select(i => $"TNew{i}"))}>";

        return $$"""

                     #region Map Extensions for Union{{genericArgs}}

                     extension{{genericArgs}}(Union{{genericArgs}} union)
                     {
                 {{Map(arities, newArgs)}}
                 {{MapAsync(arities, newArgs)}}
                     }
                     
                     extension{{genericArgs}}(Task<Union{{genericArgs}}> unionTask)
                     {
                 {{TaskMap(arities, newArgs)}}    
                 {{TaskMapAsync(arities, newArgs)}}
                     }

                     #endregion
                 """;
    }

    private static string Map(int[] arities, string newArgs)
    {
        return $$"""
                        /// <summary>
                        /// Apply mapping functions to the value stored in the union based on its current state.
                        /// </summary>
                        {{string.Join("\n       ", arities.Select(i => $"/// <param name=\"mapT{i}\">The mapping function if the union is in the T{i} state. </param>"))}}
                        public Union{{newArgs}} Map{{newArgs}}({{string.Join(", ", arities.Select(i => $"Func<T{i},TNew{i}> mapT{i}"))}})
                        {
                            {{string.Join("\n           ", arities.Select(i => $"ArgumentNullException.ThrowIfNull(mapT{i});"))}}
                            
                            return union.Match(
                               {{string.Join(",\n              ", arities.Select(i => MatchLine(i, newArgs)))}}
                            );
                        }
                 """;
    }

    private static string MapAsync(int[] arities, string newArgs)
    {
        return $$"""
                 
                        /// <summary>
                        /// Apply async mapping functions to the value stored in the union based on its current state.
                        /// </summary>
                        {{string.Join("\n       ", arities.Select(i => $"/// <param name=\"mapT{i}Async\">The async mapping function if the union is in the T{i} state. </param>"))}}
                        public Task<Union{{newArgs}}> MapAsync{{newArgs}}({{string.Join(", ", arities.Select(i => $"Func<T{i}, Task<TNew{i}>> mapT{i}Async"))}})
                        {
                            {{string.Join("\n           ", arities.Select(i => $"ArgumentNullException.ThrowIfNull(mapT{i}Async);"))}}
                            
                            return union.MatchAsync(
                               {{string.Join(",\n              ", arities.Select(i => MatchLineAsync(i, newArgs)))}}
                            );
                        }
                 """;
    }

    private static string TaskMap(int[] arities, string newArgs)
    {
        return $$"""
                 
                        /// <summary>
                        /// Apply mapping functions to the value stored in the task union based on its current state.
                        /// </summary>
                        {{string.Join("\n       ", arities.Select(i => $"/// <param name=\"mapT{i}\">The mapping function if the union is in the T{i} state. </param>"))}}
                        public async Task<Union{{newArgs}}> Map{{newArgs}}({{string.Join(", ", arities.Select(i => $"Func<T{i},TNew{i}> mapT{i}"))}})
                        {
                            var union = await unionTask.ConfigureAwait(false);
                            return union.Map({{string.Join(", ", arities.Select(i => $"mapT{i}"))}});
                        }        
                 """;
    }

    private static string TaskMapAsync(int[] arities, string newArgs)
    {
        return $$"""

                        /// <summary>
                        /// Apply async mapping functions to the value stored in the task union based on its current state.
                        /// </summary>
                        {{string.Join("\n       ", arities.Select(i => $"/// <param name=\"mapT{i}Async\">The async mapping function if the union is in the T{i} state. </param>"))}}
                        public async Task<Union{{newArgs}}> MapAsync{{newArgs}}({{string.Join(", ", arities.Select(i => $"Func<T{i}, Task<TNew{i}>> mapT{i}Async"))}})
                        {
                            var union = await unionTask.ConfigureAwait(false);
                            return await union.MapAsync({{string.Join(", ", arities.Select(i => $"mapT{i}Async"))}}).ConfigureAwait(false);
                        }
                 """;
    }

    private static string MatchLine(int arity, string newArgs)
    {
        return $"t{arity} => Union{newArgs}.FromT{arity}(mapT{arity}(t{arity}))";
    }

    private static string MatchLineAsync(int arity, string newArgs)
    {
        return $"async t{arity} => Union{newArgs}.FromT{arity}(await mapT{arity}Async(t{arity}).ConfigureAwait(false))";
    }
}
