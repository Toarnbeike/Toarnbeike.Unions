# nullable enable

// <auto-generated>
//   This file was generated by Toarnbeike.Unions.StaticGenerator.
//   Generator: MatchExtensionsGenerator (v. 1.3.0)
//   Created: 2026-02-01 12:08:01Z
//   This is an auto-generated file. Do not modify.
// </auto-generated>

namespace Toarnbeike.Unions.Generic.Extensions;

/// <summary>
/// Match: extension methods to match (fold; convert to result) union values.
/// </summary>
public static class MatchExtensions
{
    #region Match Extensions for Union<T1, T2>

    extension<T1, T2>(Union<T1, T2> union)
    {
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1">The function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2">The function to invoke when the union holds a value of type T2.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public TResult Match<TResult>(Func<T1, TResult> onT1, Func<T2, TResult> onT2)
        {
            ArgumentNullException.ThrowIfNull(onT1);
            ArgumentNullException.ThrowIfNull(onT2);

            return union.Index switch
            {
               1 => onT1(union.AsT1),
               2 => onT2(union.AsT2),
               _ => throw new InvalidOperationException($"Union index {union.Index} is invalid.")
            };
        }
        
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding async function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1Async">The async function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2Async">The async function to invoke when the union holds a value of type T2.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public Task<TResult> MatchAsync<TResult>(Func<T1, Task<TResult>> onT1Async, Func<T2, Task<TResult>> onT2Async)
        {
            ArgumentNullException.ThrowIfNull(onT1Async);
            ArgumentNullException.ThrowIfNull(onT2Async);

            return union.Index switch
            {
               1 => onT1Async(union.AsT1),
               2 => onT2Async(union.AsT2),
               _ => Task.FromException<TResult>(new InvalidOperationException($"Union index {union.Index} is invalid."))
            };
        }
    }
    
    extension<T1, T2>(Task<Union<T1, T2>> unionTask)
    {
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1">The function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2">The function to invoke when the union holds a value of type T2.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public async Task<TResult> Match<TResult>(Func<T1, TResult> onT1, Func<T2, TResult> onT2)
        {
            var union = await unionTask.ConfigureAwait(false);
            return union.Match(onT1, onT2);
       }
        
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding async function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1Async">The async function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2Async">The async function to invoke when the union holds a value of type T2.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public async Task<TResult> MatchAsync<TResult>(Func<T1, Task<TResult>> onT1Async, Func<T2, Task<TResult>> onT2Async)
        {
            var union = await unionTask.ConfigureAwait(false);
            return await union.MatchAsync(onT1Async, onT2Async).ConfigureAwait(false);
        }
    }

    #endregion

    #region Match Extensions for Union<T1, T2, T3>

    extension<T1, T2, T3>(Union<T1, T2, T3> union)
    {
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1">The function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2">The function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3">The function to invoke when the union holds a value of type T3.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public TResult Match<TResult>(Func<T1, TResult> onT1, Func<T2, TResult> onT2, Func<T3, TResult> onT3)
        {
            ArgumentNullException.ThrowIfNull(onT1);
            ArgumentNullException.ThrowIfNull(onT2);
            ArgumentNullException.ThrowIfNull(onT3);

            return union.Index switch
            {
               1 => onT1(union.AsT1),
               2 => onT2(union.AsT2),
               3 => onT3(union.AsT3),
               _ => throw new InvalidOperationException($"Union index {union.Index} is invalid.")
            };
        }
        
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding async function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1Async">The async function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2Async">The async function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3Async">The async function to invoke when the union holds a value of type T3.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public Task<TResult> MatchAsync<TResult>(Func<T1, Task<TResult>> onT1Async, Func<T2, Task<TResult>> onT2Async, Func<T3, Task<TResult>> onT3Async)
        {
            ArgumentNullException.ThrowIfNull(onT1Async);
            ArgumentNullException.ThrowIfNull(onT2Async);
            ArgumentNullException.ThrowIfNull(onT3Async);

            return union.Index switch
            {
               1 => onT1Async(union.AsT1),
               2 => onT2Async(union.AsT2),
               3 => onT3Async(union.AsT3),
               _ => Task.FromException<TResult>(new InvalidOperationException($"Union index {union.Index} is invalid."))
            };
        }
    }
    
    extension<T1, T2, T3>(Task<Union<T1, T2, T3>> unionTask)
    {
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1">The function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2">The function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3">The function to invoke when the union holds a value of type T3.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public async Task<TResult> Match<TResult>(Func<T1, TResult> onT1, Func<T2, TResult> onT2, Func<T3, TResult> onT3)
        {
            var union = await unionTask.ConfigureAwait(false);
            return union.Match(onT1, onT2, onT3);
       }
        
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding async function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1Async">The async function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2Async">The async function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3Async">The async function to invoke when the union holds a value of type T3.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public async Task<TResult> MatchAsync<TResult>(Func<T1, Task<TResult>> onT1Async, Func<T2, Task<TResult>> onT2Async, Func<T3, Task<TResult>> onT3Async)
        {
            var union = await unionTask.ConfigureAwait(false);
            return await union.MatchAsync(onT1Async, onT2Async, onT3Async).ConfigureAwait(false);
        }
    }

    #endregion

    #region Match Extensions for Union<T1, T2, T3, T4>

    extension<T1, T2, T3, T4>(Union<T1, T2, T3, T4> union)
    {
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1">The function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2">The function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3">The function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4">The function to invoke when the union holds a value of type T4.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public TResult Match<TResult>(Func<T1, TResult> onT1, Func<T2, TResult> onT2, Func<T3, TResult> onT3, Func<T4, TResult> onT4)
        {
            ArgumentNullException.ThrowIfNull(onT1);
            ArgumentNullException.ThrowIfNull(onT2);
            ArgumentNullException.ThrowIfNull(onT3);
            ArgumentNullException.ThrowIfNull(onT4);

            return union.Index switch
            {
               1 => onT1(union.AsT1),
               2 => onT2(union.AsT2),
               3 => onT3(union.AsT3),
               4 => onT4(union.AsT4),
               _ => throw new InvalidOperationException($"Union index {union.Index} is invalid.")
            };
        }
        
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding async function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1Async">The async function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2Async">The async function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3Async">The async function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4Async">The async function to invoke when the union holds a value of type T4.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public Task<TResult> MatchAsync<TResult>(Func<T1, Task<TResult>> onT1Async, Func<T2, Task<TResult>> onT2Async, Func<T3, Task<TResult>> onT3Async, Func<T4, Task<TResult>> onT4Async)
        {
            ArgumentNullException.ThrowIfNull(onT1Async);
            ArgumentNullException.ThrowIfNull(onT2Async);
            ArgumentNullException.ThrowIfNull(onT3Async);
            ArgumentNullException.ThrowIfNull(onT4Async);

            return union.Index switch
            {
               1 => onT1Async(union.AsT1),
               2 => onT2Async(union.AsT2),
               3 => onT3Async(union.AsT3),
               4 => onT4Async(union.AsT4),
               _ => Task.FromException<TResult>(new InvalidOperationException($"Union index {union.Index} is invalid."))
            };
        }
    }
    
    extension<T1, T2, T3, T4>(Task<Union<T1, T2, T3, T4>> unionTask)
    {
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1">The function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2">The function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3">The function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4">The function to invoke when the union holds a value of type T4.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public async Task<TResult> Match<TResult>(Func<T1, TResult> onT1, Func<T2, TResult> onT2, Func<T3, TResult> onT3, Func<T4, TResult> onT4)
        {
            var union = await unionTask.ConfigureAwait(false);
            return union.Match(onT1, onT2, onT3, onT4);
       }
        
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding async function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1Async">The async function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2Async">The async function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3Async">The async function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4Async">The async function to invoke when the union holds a value of type T4.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public async Task<TResult> MatchAsync<TResult>(Func<T1, Task<TResult>> onT1Async, Func<T2, Task<TResult>> onT2Async, Func<T3, Task<TResult>> onT3Async, Func<T4, Task<TResult>> onT4Async)
        {
            var union = await unionTask.ConfigureAwait(false);
            return await union.MatchAsync(onT1Async, onT2Async, onT3Async, onT4Async).ConfigureAwait(false);
        }
    }

    #endregion

    #region Match Extensions for Union<T1, T2, T3, T4, T5>

    extension<T1, T2, T3, T4, T5>(Union<T1, T2, T3, T4, T5> union)
    {
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1">The function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2">The function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3">The function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4">The function to invoke when the union holds a value of type T4.</param>
        /// <param name="onT5">The function to invoke when the union holds a value of type T5.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public TResult Match<TResult>(Func<T1, TResult> onT1, Func<T2, TResult> onT2, Func<T3, TResult> onT3, Func<T4, TResult> onT4, Func<T5, TResult> onT5)
        {
            ArgumentNullException.ThrowIfNull(onT1);
            ArgumentNullException.ThrowIfNull(onT2);
            ArgumentNullException.ThrowIfNull(onT3);
            ArgumentNullException.ThrowIfNull(onT4);
            ArgumentNullException.ThrowIfNull(onT5);

            return union.Index switch
            {
               1 => onT1(union.AsT1),
               2 => onT2(union.AsT2),
               3 => onT3(union.AsT3),
               4 => onT4(union.AsT4),
               5 => onT5(union.AsT5),
               _ => throw new InvalidOperationException($"Union index {union.Index} is invalid.")
            };
        }
        
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding async function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1Async">The async function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2Async">The async function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3Async">The async function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4Async">The async function to invoke when the union holds a value of type T4.</param>
        /// <param name="onT5Async">The async function to invoke when the union holds a value of type T5.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public Task<TResult> MatchAsync<TResult>(Func<T1, Task<TResult>> onT1Async, Func<T2, Task<TResult>> onT2Async, Func<T3, Task<TResult>> onT3Async, Func<T4, Task<TResult>> onT4Async, Func<T5, Task<TResult>> onT5Async)
        {
            ArgumentNullException.ThrowIfNull(onT1Async);
            ArgumentNullException.ThrowIfNull(onT2Async);
            ArgumentNullException.ThrowIfNull(onT3Async);
            ArgumentNullException.ThrowIfNull(onT4Async);
            ArgumentNullException.ThrowIfNull(onT5Async);

            return union.Index switch
            {
               1 => onT1Async(union.AsT1),
               2 => onT2Async(union.AsT2),
               3 => onT3Async(union.AsT3),
               4 => onT4Async(union.AsT4),
               5 => onT5Async(union.AsT5),
               _ => Task.FromException<TResult>(new InvalidOperationException($"Union index {union.Index} is invalid."))
            };
        }
    }
    
    extension<T1, T2, T3, T4, T5>(Task<Union<T1, T2, T3, T4, T5>> unionTask)
    {
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1">The function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2">The function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3">The function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4">The function to invoke when the union holds a value of type T4.</param>
        /// <param name="onT5">The function to invoke when the union holds a value of type T5.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public async Task<TResult> Match<TResult>(Func<T1, TResult> onT1, Func<T2, TResult> onT2, Func<T3, TResult> onT3, Func<T4, TResult> onT4, Func<T5, TResult> onT5)
        {
            var union = await unionTask.ConfigureAwait(false);
            return union.Match(onT1, onT2, onT3, onT4, onT5);
       }
        
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding async function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1Async">The async function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2Async">The async function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3Async">The async function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4Async">The async function to invoke when the union holds a value of type T4.</param>
        /// <param name="onT5Async">The async function to invoke when the union holds a value of type T5.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public async Task<TResult> MatchAsync<TResult>(Func<T1, Task<TResult>> onT1Async, Func<T2, Task<TResult>> onT2Async, Func<T3, Task<TResult>> onT3Async, Func<T4, Task<TResult>> onT4Async, Func<T5, Task<TResult>> onT5Async)
        {
            var union = await unionTask.ConfigureAwait(false);
            return await union.MatchAsync(onT1Async, onT2Async, onT3Async, onT4Async, onT5Async).ConfigureAwait(false);
        }
    }

    #endregion

    #region Match Extensions for Union<T1, T2, T3, T4, T5, T6>

    extension<T1, T2, T3, T4, T5, T6>(Union<T1, T2, T3, T4, T5, T6> union)
    {
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1">The function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2">The function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3">The function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4">The function to invoke when the union holds a value of type T4.</param>
        /// <param name="onT5">The function to invoke when the union holds a value of type T5.</param>
        /// <param name="onT6">The function to invoke when the union holds a value of type T6.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public TResult Match<TResult>(Func<T1, TResult> onT1, Func<T2, TResult> onT2, Func<T3, TResult> onT3, Func<T4, TResult> onT4, Func<T5, TResult> onT5, Func<T6, TResult> onT6)
        {
            ArgumentNullException.ThrowIfNull(onT1);
            ArgumentNullException.ThrowIfNull(onT2);
            ArgumentNullException.ThrowIfNull(onT3);
            ArgumentNullException.ThrowIfNull(onT4);
            ArgumentNullException.ThrowIfNull(onT5);
            ArgumentNullException.ThrowIfNull(onT6);

            return union.Index switch
            {
               1 => onT1(union.AsT1),
               2 => onT2(union.AsT2),
               3 => onT3(union.AsT3),
               4 => onT4(union.AsT4),
               5 => onT5(union.AsT5),
               6 => onT6(union.AsT6),
               _ => throw new InvalidOperationException($"Union index {union.Index} is invalid.")
            };
        }
        
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding async function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1Async">The async function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2Async">The async function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3Async">The async function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4Async">The async function to invoke when the union holds a value of type T4.</param>
        /// <param name="onT5Async">The async function to invoke when the union holds a value of type T5.</param>
        /// <param name="onT6Async">The async function to invoke when the union holds a value of type T6.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public Task<TResult> MatchAsync<TResult>(Func<T1, Task<TResult>> onT1Async, Func<T2, Task<TResult>> onT2Async, Func<T3, Task<TResult>> onT3Async, Func<T4, Task<TResult>> onT4Async, Func<T5, Task<TResult>> onT5Async, Func<T6, Task<TResult>> onT6Async)
        {
            ArgumentNullException.ThrowIfNull(onT1Async);
            ArgumentNullException.ThrowIfNull(onT2Async);
            ArgumentNullException.ThrowIfNull(onT3Async);
            ArgumentNullException.ThrowIfNull(onT4Async);
            ArgumentNullException.ThrowIfNull(onT5Async);
            ArgumentNullException.ThrowIfNull(onT6Async);

            return union.Index switch
            {
               1 => onT1Async(union.AsT1),
               2 => onT2Async(union.AsT2),
               3 => onT3Async(union.AsT3),
               4 => onT4Async(union.AsT4),
               5 => onT5Async(union.AsT5),
               6 => onT6Async(union.AsT6),
               _ => Task.FromException<TResult>(new InvalidOperationException($"Union index {union.Index} is invalid."))
            };
        }
    }
    
    extension<T1, T2, T3, T4, T5, T6>(Task<Union<T1, T2, T3, T4, T5, T6>> unionTask)
    {
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1">The function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2">The function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3">The function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4">The function to invoke when the union holds a value of type T4.</param>
        /// <param name="onT5">The function to invoke when the union holds a value of type T5.</param>
        /// <param name="onT6">The function to invoke when the union holds a value of type T6.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public async Task<TResult> Match<TResult>(Func<T1, TResult> onT1, Func<T2, TResult> onT2, Func<T3, TResult> onT3, Func<T4, TResult> onT4, Func<T5, TResult> onT5, Func<T6, TResult> onT6)
        {
            var union = await unionTask.ConfigureAwait(false);
            return union.Match(onT1, onT2, onT3, onT4, onT5, onT6);
       }
        
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding async function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1Async">The async function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2Async">The async function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3Async">The async function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4Async">The async function to invoke when the union holds a value of type T4.</param>
        /// <param name="onT5Async">The async function to invoke when the union holds a value of type T5.</param>
        /// <param name="onT6Async">The async function to invoke when the union holds a value of type T6.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public async Task<TResult> MatchAsync<TResult>(Func<T1, Task<TResult>> onT1Async, Func<T2, Task<TResult>> onT2Async, Func<T3, Task<TResult>> onT3Async, Func<T4, Task<TResult>> onT4Async, Func<T5, Task<TResult>> onT5Async, Func<T6, Task<TResult>> onT6Async)
        {
            var union = await unionTask.ConfigureAwait(false);
            return await union.MatchAsync(onT1Async, onT2Async, onT3Async, onT4Async, onT5Async, onT6Async).ConfigureAwait(false);
        }
    }

    #endregion

    #region Match Extensions for Union<T1, T2, T3, T4, T5, T6, T7>

    extension<T1, T2, T3, T4, T5, T6, T7>(Union<T1, T2, T3, T4, T5, T6, T7> union)
    {
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1">The function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2">The function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3">The function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4">The function to invoke when the union holds a value of type T4.</param>
        /// <param name="onT5">The function to invoke when the union holds a value of type T5.</param>
        /// <param name="onT6">The function to invoke when the union holds a value of type T6.</param>
        /// <param name="onT7">The function to invoke when the union holds a value of type T7.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public TResult Match<TResult>(Func<T1, TResult> onT1, Func<T2, TResult> onT2, Func<T3, TResult> onT3, Func<T4, TResult> onT4, Func<T5, TResult> onT5, Func<T6, TResult> onT6, Func<T7, TResult> onT7)
        {
            ArgumentNullException.ThrowIfNull(onT1);
            ArgumentNullException.ThrowIfNull(onT2);
            ArgumentNullException.ThrowIfNull(onT3);
            ArgumentNullException.ThrowIfNull(onT4);
            ArgumentNullException.ThrowIfNull(onT5);
            ArgumentNullException.ThrowIfNull(onT6);
            ArgumentNullException.ThrowIfNull(onT7);

            return union.Index switch
            {
               1 => onT1(union.AsT1),
               2 => onT2(union.AsT2),
               3 => onT3(union.AsT3),
               4 => onT4(union.AsT4),
               5 => onT5(union.AsT5),
               6 => onT6(union.AsT6),
               7 => onT7(union.AsT7),
               _ => throw new InvalidOperationException($"Union index {union.Index} is invalid.")
            };
        }
        
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding async function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1Async">The async function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2Async">The async function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3Async">The async function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4Async">The async function to invoke when the union holds a value of type T4.</param>
        /// <param name="onT5Async">The async function to invoke when the union holds a value of type T5.</param>
        /// <param name="onT6Async">The async function to invoke when the union holds a value of type T6.</param>
        /// <param name="onT7Async">The async function to invoke when the union holds a value of type T7.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public Task<TResult> MatchAsync<TResult>(Func<T1, Task<TResult>> onT1Async, Func<T2, Task<TResult>> onT2Async, Func<T3, Task<TResult>> onT3Async, Func<T4, Task<TResult>> onT4Async, Func<T5, Task<TResult>> onT5Async, Func<T6, Task<TResult>> onT6Async, Func<T7, Task<TResult>> onT7Async)
        {
            ArgumentNullException.ThrowIfNull(onT1Async);
            ArgumentNullException.ThrowIfNull(onT2Async);
            ArgumentNullException.ThrowIfNull(onT3Async);
            ArgumentNullException.ThrowIfNull(onT4Async);
            ArgumentNullException.ThrowIfNull(onT5Async);
            ArgumentNullException.ThrowIfNull(onT6Async);
            ArgumentNullException.ThrowIfNull(onT7Async);

            return union.Index switch
            {
               1 => onT1Async(union.AsT1),
               2 => onT2Async(union.AsT2),
               3 => onT3Async(union.AsT3),
               4 => onT4Async(union.AsT4),
               5 => onT5Async(union.AsT5),
               6 => onT6Async(union.AsT6),
               7 => onT7Async(union.AsT7),
               _ => Task.FromException<TResult>(new InvalidOperationException($"Union index {union.Index} is invalid."))
            };
        }
    }
    
    extension<T1, T2, T3, T4, T5, T6, T7>(Task<Union<T1, T2, T3, T4, T5, T6, T7>> unionTask)
    {
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1">The function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2">The function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3">The function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4">The function to invoke when the union holds a value of type T4.</param>
        /// <param name="onT5">The function to invoke when the union holds a value of type T5.</param>
        /// <param name="onT6">The function to invoke when the union holds a value of type T6.</param>
        /// <param name="onT7">The function to invoke when the union holds a value of type T7.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public async Task<TResult> Match<TResult>(Func<T1, TResult> onT1, Func<T2, TResult> onT2, Func<T3, TResult> onT3, Func<T4, TResult> onT4, Func<T5, TResult> onT5, Func<T6, TResult> onT6, Func<T7, TResult> onT7)
        {
            var union = await unionTask.ConfigureAwait(false);
            return union.Match(onT1, onT2, onT3, onT4, onT5, onT6, onT7);
       }
        
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding async function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1Async">The async function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2Async">The async function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3Async">The async function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4Async">The async function to invoke when the union holds a value of type T4.</param>
        /// <param name="onT5Async">The async function to invoke when the union holds a value of type T5.</param>
        /// <param name="onT6Async">The async function to invoke when the union holds a value of type T6.</param>
        /// <param name="onT7Async">The async function to invoke when the union holds a value of type T7.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public async Task<TResult> MatchAsync<TResult>(Func<T1, Task<TResult>> onT1Async, Func<T2, Task<TResult>> onT2Async, Func<T3, Task<TResult>> onT3Async, Func<T4, Task<TResult>> onT4Async, Func<T5, Task<TResult>> onT5Async, Func<T6, Task<TResult>> onT6Async, Func<T7, Task<TResult>> onT7Async)
        {
            var union = await unionTask.ConfigureAwait(false);
            return await union.MatchAsync(onT1Async, onT2Async, onT3Async, onT4Async, onT5Async, onT6Async, onT7Async).ConfigureAwait(false);
        }
    }

    #endregion

    #region Match Extensions for Union<T1, T2, T3, T4, T5, T6, T7, T8>

    extension<T1, T2, T3, T4, T5, T6, T7, T8>(Union<T1, T2, T3, T4, T5, T6, T7, T8> union)
    {
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1">The function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2">The function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3">The function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4">The function to invoke when the union holds a value of type T4.</param>
        /// <param name="onT5">The function to invoke when the union holds a value of type T5.</param>
        /// <param name="onT6">The function to invoke when the union holds a value of type T6.</param>
        /// <param name="onT7">The function to invoke when the union holds a value of type T7.</param>
        /// <param name="onT8">The function to invoke when the union holds a value of type T8.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public TResult Match<TResult>(Func<T1, TResult> onT1, Func<T2, TResult> onT2, Func<T3, TResult> onT3, Func<T4, TResult> onT4, Func<T5, TResult> onT5, Func<T6, TResult> onT6, Func<T7, TResult> onT7, Func<T8, TResult> onT8)
        {
            ArgumentNullException.ThrowIfNull(onT1);
            ArgumentNullException.ThrowIfNull(onT2);
            ArgumentNullException.ThrowIfNull(onT3);
            ArgumentNullException.ThrowIfNull(onT4);
            ArgumentNullException.ThrowIfNull(onT5);
            ArgumentNullException.ThrowIfNull(onT6);
            ArgumentNullException.ThrowIfNull(onT7);
            ArgumentNullException.ThrowIfNull(onT8);

            return union.Index switch
            {
               1 => onT1(union.AsT1),
               2 => onT2(union.AsT2),
               3 => onT3(union.AsT3),
               4 => onT4(union.AsT4),
               5 => onT5(union.AsT5),
               6 => onT6(union.AsT6),
               7 => onT7(union.AsT7),
               8 => onT8(union.AsT8),
               _ => throw new InvalidOperationException($"Union index {union.Index} is invalid.")
            };
        }
        
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding async function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1Async">The async function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2Async">The async function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3Async">The async function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4Async">The async function to invoke when the union holds a value of type T4.</param>
        /// <param name="onT5Async">The async function to invoke when the union holds a value of type T5.</param>
        /// <param name="onT6Async">The async function to invoke when the union holds a value of type T6.</param>
        /// <param name="onT7Async">The async function to invoke when the union holds a value of type T7.</param>
        /// <param name="onT8Async">The async function to invoke when the union holds a value of type T8.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public Task<TResult> MatchAsync<TResult>(Func<T1, Task<TResult>> onT1Async, Func<T2, Task<TResult>> onT2Async, Func<T3, Task<TResult>> onT3Async, Func<T4, Task<TResult>> onT4Async, Func<T5, Task<TResult>> onT5Async, Func<T6, Task<TResult>> onT6Async, Func<T7, Task<TResult>> onT7Async, Func<T8, Task<TResult>> onT8Async)
        {
            ArgumentNullException.ThrowIfNull(onT1Async);
            ArgumentNullException.ThrowIfNull(onT2Async);
            ArgumentNullException.ThrowIfNull(onT3Async);
            ArgumentNullException.ThrowIfNull(onT4Async);
            ArgumentNullException.ThrowIfNull(onT5Async);
            ArgumentNullException.ThrowIfNull(onT6Async);
            ArgumentNullException.ThrowIfNull(onT7Async);
            ArgumentNullException.ThrowIfNull(onT8Async);

            return union.Index switch
            {
               1 => onT1Async(union.AsT1),
               2 => onT2Async(union.AsT2),
               3 => onT3Async(union.AsT3),
               4 => onT4Async(union.AsT4),
               5 => onT5Async(union.AsT5),
               6 => onT6Async(union.AsT6),
               7 => onT7Async(union.AsT7),
               8 => onT8Async(union.AsT8),
               _ => Task.FromException<TResult>(new InvalidOperationException($"Union index {union.Index} is invalid."))
            };
        }
    }
    
    extension<T1, T2, T3, T4, T5, T6, T7, T8>(Task<Union<T1, T2, T3, T4, T5, T6, T7, T8>> unionTask)
    {
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1">The function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2">The function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3">The function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4">The function to invoke when the union holds a value of type T4.</param>
        /// <param name="onT5">The function to invoke when the union holds a value of type T5.</param>
        /// <param name="onT6">The function to invoke when the union holds a value of type T6.</param>
        /// <param name="onT7">The function to invoke when the union holds a value of type T7.</param>
        /// <param name="onT8">The function to invoke when the union holds a value of type T8.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public async Task<TResult> Match<TResult>(Func<T1, TResult> onT1, Func<T2, TResult> onT2, Func<T3, TResult> onT3, Func<T4, TResult> onT4, Func<T5, TResult> onT5, Func<T6, TResult> onT6, Func<T7, TResult> onT7, Func<T8, TResult> onT8)
        {
            var union = await unionTask.ConfigureAwait(false);
            return union.Match(onT1, onT2, onT3, onT4, onT5, onT6, onT7, onT8);
       }
        
        /// <summary>
        /// Matches the value stored in the union and invokes the corresponding async function based on its type.
        /// </summary>
        /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
        /// <param name="onT1Async">The async function to invoke when the union holds a value of type T1.</param>
        /// <param name="onT2Async">The async function to invoke when the union holds a value of type T2.</param>
        /// <param name="onT3Async">The async function to invoke when the union holds a value of type T3.</param>
        /// <param name="onT4Async">The async function to invoke when the union holds a value of type T4.</param>
        /// <param name="onT5Async">The async function to invoke when the union holds a value of type T5.</param>
        /// <param name="onT6Async">The async function to invoke when the union holds a value of type T6.</param>
        /// <param name="onT7Async">The async function to invoke when the union holds a value of type T7.</param>
        /// <param name="onT8Async">The async function to invoke when the union holds a value of type T8.</param>
        /// <returns>The result of invoking the appropriate match function.</returns>
        /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
        public async Task<TResult> MatchAsync<TResult>(Func<T1, Task<TResult>> onT1Async, Func<T2, Task<TResult>> onT2Async, Func<T3, Task<TResult>> onT3Async, Func<T4, Task<TResult>> onT4Async, Func<T5, Task<TResult>> onT5Async, Func<T6, Task<TResult>> onT6Async, Func<T7, Task<TResult>> onT7Async, Func<T8, Task<TResult>> onT8Async)
        {
            var union = await unionTask.ConfigureAwait(false);
            return await union.MatchAsync(onT1Async, onT2Async, onT3Async, onT4Async, onT5Async, onT6Async, onT7Async, onT8Async).ConfigureAwait(false);
        }
    }

    #endregion
}