using Microsoft.CodeAnalysis;

namespace Toarnbeike.Unions.Generators;

using Toarnbeike.Unions.Model;

internal static class MatchGenerator
{
    public static string Execute(UnionModel model)
    {
        var parameters = string.Join(",\n            ",
            model.Cases.Select(c => $"Func<{c.TypeName}, TResult> {c.ArgumentName}"));

        var parametersAsync = string.Join(",\n            ",
            model.Cases.Select(c => $"Func<{c.TypeName}, Task<TResult>> {c.ArgumentName}"));

        var arguments = string.Join(", ", model.Cases.Select(c => c.ArgumentName));

        var xmlParameters = string.Join("\n        ", model.Cases.Select(c =>
            $"/// <param name=\"{c.ArgumentName}\">The function to invoke when the union holds a {c.Name} value.</param>"));


        return $$"""
            # nullable enable
            
            // <auto-generated>
            //   This file was generated by Toarnbeike.Unions.SourceGenerator.
            //   Generator: {{nameof(MatchGenerator)}}
            //   Created: {{DateTime.UtcNow:u}}
            //   This is an auto-generated file. Do not modify.
            // </auto-generated>
            
            using System.Diagnostics;
            using System.Diagnostics.CodeAnalysis;
            using Toarnbeike.Unions;
            using Toarnbeike.Unions.Extensions;
            {{model.CaseUsings}}

            namespace {{model.Namespace}};

            /// <summary>
            /// Match: extension methods to match (fold; convert to result) union values.
            /// </summary>
            public static class {{model.Name}}MatchExtensions
            {
                extension({{model.Name}} {{model.ArgumentName}})
                {
                    /// <summary>
                    /// Matches the value stored in the union and invokes the corresponding function based on its type.
                    /// </summary>
                    /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
                    {{xmlParameters}}
                    /// <returns>The result of invoking the appropriate match function.</returns>
                    /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
                    public TResult Match<TResult>(
                        {{parameters}})
                        => {{model.ArgumentName}}.AsUnion().Match({{arguments}});
            
                    /// <summary>
                    /// Matches the value stored in the union and invokes the corresponding async function based on its type.
                    /// </summary>
                    /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
                    {{xmlParameters}}
                    /// <returns>The result of invoking the appropriate match function.</returns>
                    /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
                    public Task<TResult> MatchAsync<TResult>(
                        {{parametersAsync}})
                        => {{model.ArgumentName}}.AsUnion().MatchAsync({{arguments}});
                }
                extension(Task<{{model.Name}}> {{model.ArgumentName}}Task)
                {
                    /// <summary>
                    /// Matches the value stored in the union and invokes the corresponding function based on its type.
                    /// </summary>
                    /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
                    {{xmlParameters}}
                    /// <returns>The result of invoking the appropriate match function.</returns>
                    /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
                    public async Task<TResult> Match<TResult>(
                        {{parameters}})
                    {
                        var {{model.ArgumentName}} = await {{model.ArgumentName}}Task.ConfigureAwait(false);
                        return {{model.ArgumentName}}.Match({{arguments}});
                    }

                    /// <summary>
                    /// Matches the value stored in the union and invokes the corresponding async function based on its type.
                    /// </summary>
                    /// <typeparam name="TResult">The type of the result returned by the match functions.</typeparam>
                    {{xmlParameters}}
                    /// <returns>The result of invoking the appropriate match function.</returns>
                    /// <exception cref="InvalidOperationException">Thrown if the union is not in a valid state.</exception>
                    public async Task<TResult> MatchAsync<TResult>(
                        {{parametersAsync}})
                    {
                        var {{model.ArgumentName}} = await {{model.ArgumentName}}Task.ConfigureAwait(false);
                        return await {{model.ArgumentName}}.MatchAsync({{arguments}}).ConfigureAwait(false);
                    }
                }
            }
            """;
    }
}
